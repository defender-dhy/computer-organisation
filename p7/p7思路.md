1. - P7相对于P6的顶层模块**新增了两个接口**：

2. 1. addr[31:0]：表示整个CPU“宏观”运行指令所对应的PC地址。所谓“宏观”指令，表示该指令之前的所有指令序列对CPU的更新已完成，该指令及其之后的指令序列对CPU的更新未完成。
   2. interrupt：来自系统外的中断信号，每次中断信号均会持续5-10周期，处理该中断信号的方式与处理内部timer模拟的中断信号行为应保持一致。

3. 支持的异常：

4. 

5. | ExcCode | 助记符 | 描述                                        |
   | ------- | ------ | ------------------------------------------- |
   | 0       | Int    | 中断                                        |
   | 4       | AdEL   | 取数或取指时地址错误                        |
   | 5       | AdES   | 存数时地址错误                              |
   | 10      | RI     | 不认识的（或者非法的）指令码                |
   | 12      | Ov     | 自陷形式的整数算术指令（例如add）导致的溢出 |

6. Timer0输出的中断请求信号接入HWInt[2] (最低中断位)，Timer1输出的中断请求信号接入HWInt[3]，来自MIPS微系统外部的中断请求信号接入HWInt[4]。

7. ![img](http://cscore.net.cn/assets/courseware/v1/2945b6ec5e76ec319986de33df7884db/asset-v1:Internal+B3I062410+2020_T1+type@asset+block/P7_2019_%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png)

### Bridge

![屏幕截图 2020-12-26 124404.jpg](https://i.loli.net/2020/12/26/BxR3APwMdGS7NzI.jpg)



### CP0

1. 寄存器：为了支持异常和中断,流水线必须支持0号协处理器（CP0），必须实现的寄存器包括:**SR、CAUSE、EPC、PrID**。

## 异常与中断的行为规范

> 概念解释：
>
> 1. 受害指令：受害指令是与异常相关的概念，对中断是否指定受害指令不做要求。当受害指令提交至CP0时，便会触发对应异常，这里我们需要将”受害“和”犯罪“的概念相区分，对于多数异常的情况”受害=犯罪“；但少数”受害 != 犯罪“，例如对于j，jr，jal，jalr指令，若跳转至不对齐的地址，则受害指令应当是PC值不正确的指令。
> 2. 执行效果：我们可以这样简单地看：硬件 = 组合逻辑+时序逻辑，真正有”记忆“的是时序逻辑，因而一条或多条指令的执行效果可以被理解为对内存、各类寄存器等时序部件产生的影响。有些指令连续地重复执行多次后时序部件数据可能保持一致，如mul、mthi等；而有的则并不一定保持一致，如add、sub等。

优先级：中断优先级高于异常优先级

CP0寄存器：当中断异常发生时，会向CP0寄存器对应位写入相关值，至少需要实现：屏蔽所有中断、记录中断异常类型、记录是否分支延迟（BD）、在EPC记录地址。

### 异常行为规范

1. 精确异常：对所有异常都应遵循精确异常的处理规则：即受害指令的前序指令的期望的执行效果都应执行，并且受害指令的后序指令执行效果不影响异常处理程序返回后所执行指令的执行效果。通俗来讲，就是流水线中的每条指令要么执行完毕，要么就像我们根本没见过一样。（此部分需要结合软件的行为规范理解）。

![img](http://cscore.net.cn/assets/courseware/v1/26e3203391a8cb0a5763ec700fa2887b/asset-v1:Internal+B3I062410+2020_T1+type@asset+block/P7_2019_%E5%BC%82%E5%B8%B8%E7%BB%86%E8%8A%82.png)

- 分支跳转指令无论跳转与否，延迟槽指令为受害指令时BD均需要置位。 

### 中断行为规范

1. 规范：本实验不要求在中断发生时指定具体受害指令，但需要保证中断的处理是精确的——内核态前后每条指令的执行效果不变（此部分需要结合软件的行为规范理解）。

2. 细节规范：

3. 1. 除了使用两个定时器模拟来自CPU的外部中断外，CPU还需要相应来自mips模块外的外部中断信号。

## 软件行为规范

#### 异常与中断的处理流程：

Step1-引导与识别：读取Cause和EPC寄存器，判断错误类型。

Step2-构造异常处理环境：保存现场。

Step3-处理异常：根据异常类型和其他属性执行对应处理。

Step4-准备返回：恢复现场。

Step5-从异常返回：eret指令。

针对各类中断和异常，软件对应Step3具体对应的处理是：

- 若为中断，则视情况对外设进行操作（如修改计时器的设置），EPC不作修改。
- 若为取数异常/存数异常/算术溢出，则视情况修改EPC为受害指令的下一条。
- 若为取指异常/RI，则更改EPC的值为受害指令的下一条。

#### 定时器操作规范

- 软件只会对定时器进行一些 **正常并且合理** 的操作，对于定时器的操作一共有两部分：一部分是程序开始时会设置两个定时器的模式；另一部分是中断发生进入异常处理后，软件会修改定时器的一些设置。并且先停止计数，修改外其他设置后再允许计数。除这两种情况外，测试程序保证 CPU 正确执行时不会再对定时器的设置进行修改。

#### 软件其他规范

- eret只会出现在异常处理程序中。
- 软件保证不会写入Cause和PRId。
- 软件只会在上述情况中写入EPC。
- 中断处理程序除了上述描述的操作外，还会进行一些对寄存器和内存的读写来验证CPU 的正确性。
- 中断处理程序中保证不出现异常。

### 协处理器

- 指令：MFC0、MTC0 
  - 不能直接修改CP0寄存器，必须借助通用寄存器 

- MFC0：读取CP0寄存器至通用寄存器 
  - SR：获取处理器的控制信息 
  - Cause：获取处理器当前所处于的状态 
  - EPC：获取被异常/中断的指令地址 
  - PRId：读取处理器ID（可以读取你的个性签名) 
- MTC0：通用寄存器值写入CP0寄存器 
  - SR：对处理器进行控制，例如关闭中断 
  - EPC：操作系统中将用于多任务切换

Cause：

![屏幕截图 2020-12-24 103628.jpg](https://i.loli.net/2020/12/24/6jcpZFyiesuSkxL.jpg) 